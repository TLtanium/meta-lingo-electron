/**
 * Legacy Word Cloud Component
 * Displays word cloud image generated by backend Python wordcloud engine
 */

import { useState, useEffect } from 'react'
import {
  Box,
  Alert,
  Typography,
  CircularProgress
} from '@mui/material'
import { useTranslation } from 'react-i18next'
import type { WordFrequencyResult } from '../../../types/wordFrequency'
import { analysisApi } from '../../../api'

interface LegacyWordCloudProps {
  data: WordFrequencyResult[]
  config: {
    maxWords: number
    useAllWords?: boolean
    style: string
    colormap?: string
    maskImage?: string | null
  }
  onWordClick?: (word: string) => void
}

// Map frontend style to backend style (Chinese)
const STYLE_MAP: Record<string, string> = {
  'default': '默认',
  'mask': '使用蒙版',
  'imageColor': '基于图片颜色'
}

export default function LegacyWordCloud({
  data,
  config,
  onWordClick
}: LegacyWordCloudProps) {
  const { t } = useTranslation()
  const [imageData, setImageData] = useState<string | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Generate word cloud when data or config changes
  useEffect(() => {
    if (data.length === 0) {
      setImageData(null)
      setError(null)
      return
    }

    const generateWordCloud = async () => {
      setLoading(true)
      setError(null)

      try {
        // Prepare word frequency dictionary
        // If useAllWords is true, use all words; otherwise use maxWords
        const useAllWords = (config as any).useAllWords || false
        // Get the actual max words to use - if useAllWords is false, use config.maxWords, but cap at data.length
        const maxWordsToUse = useAllWords ? data.length : Math.min(config.maxWords || 100, data.length)
        const wordFreq: Record<string, number> = {}
        
        // Only slice the data we need
        data.slice(0, maxWordsToUse).forEach(item => {
          wordFreq[item.word] = item.frequency
        })

        // Check if we have any words
        if (Object.keys(wordFreq).length === 0) {
          setError(t('wordFrequency.viz.noData'))
          setLoading(false)
          return
        }

        console.log('Generating word cloud with:', {
          wordCount: Object.keys(wordFreq).length,
          maxWordsToUse,
          useAllWords,
          style: config.style,
          hasMask: !!config.maskImage
        })

        // Map style to backend format
        const backendStyle = STYLE_MAP[config.style] || '默认'

        // Prepare mask image (convert File to base64 if needed)
        let maskImageBase64: string | null = null
        if (config.maskImage) {
          // If it's already a data URL, use it directly
          if (config.maskImage.startsWith('data:image')) {
            maskImageBase64 = config.maskImage
          } else {
            // Assume it's a base64 string, add data URL prefix
            maskImageBase64 = config.maskImage
          }
        }

        // Call API to generate word cloud
        // Pass the actual number of words in wordFreq, not a large number
        // The backend will use this to limit word cloud generation
        const apiMaxWords = useAllWords ? 999999 : Object.keys(wordFreq).length
        const response = await analysisApi.generateWordCloud({
          word_freq: wordFreq,
          max_words: apiMaxWords,
          mask_image: maskImageBase64,
          colormap: config.colormap,
          style: backendStyle,
          contour_width: 0,
          contour_color: 'black'
        })

        // API client returns { success, data } format
        console.log('API response:', response)
        
        if (response.success && response.data) {
          const result = response.data
          if (result.success && result.image_data) {
            console.log('Word cloud generated successfully')
            setImageData(result.image_data)
          } else {
            const errorMsg = result.error || t('wordFrequency.viz.wordCloudConfig.generateError')
            console.error('Word cloud generation failed:', errorMsg, result)
            setError(errorMsg)
          }
        } else {
          const errorMsg = response.error || t('wordFrequency.viz.wordCloudConfig.generateError')
          console.error('Word cloud API call failed:', errorMsg, response)
          setError(errorMsg)
        }
      } catch (err: any) {
        console.error('Word cloud generation error:', err)
        const errorMsg = err.response?.data?.error || err.message || t('wordFrequency.viz.wordCloudConfig.generateError')
        setError(errorMsg)
      } finally {
        setLoading(false)
      }
    }

    generateWordCloud()
  }, [data, config, t])

  // Handle image click (word click detection)
  const handleImageClick = (event: React.MouseEvent<HTMLImageElement>) => {
    if (!onWordClick) return
    
    // Note: Word click detection in image is complex
    // For now, we'll just pass the event
    // In a full implementation, you might want to overlay clickable areas
    const img = event.currentTarget
    const rect = img.getBoundingClientRect()
    const x = event.clientX - rect.left
    const y = event.clientY - rect.top
    
    // Simple heuristic: find closest word by position
    // This is a simplified version - full implementation would require
    // backend to return word positions
    console.log('Image clicked at:', x, y)
  }

  return (
    <Box 
      sx={{ 
        width: '100%', 
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'hidden',
        position: 'relative'
      }}
    >
      {/* Loading State */}
      {loading && (
        <Box 
          sx={{ 
            flex: 1, 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center',
            flexDirection: 'column',
            gap: 2
          }}
        >
          <CircularProgress />
          <Typography variant="body2" color="text.secondary">
            {t('wordFrequency.viz.wordCloudConfig.generating')}
          </Typography>
        </Box>
      )}

      {/* Error Display */}
      {error && !loading && (
        <Alert severity="error" sx={{ m: 2 }}>
          {error}
        </Alert>
      )}

      {/* Empty Data Display */}
      {data.length === 0 && !loading && !error && (
        <Box 
          sx={{ 
            flex: 1, 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center',
            color: 'text.secondary',
            flexDirection: 'column',
            gap: 2
          }}
        >
          <Typography variant="h6">{t('wordFrequency.viz.noData')}</Typography>
          <Typography variant="body2">
            {t('wordFrequency.viz.runAnalysisFirst')}
          </Typography>
        </Box>
      )}

      {/* Image Display */}
      {imageData && !loading && !error && (
        <Box 
          sx={{ 
            flex: 1,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            overflow: 'auto',
            p: 1
          }}
        >
          <img
            src={imageData}
            alt={t('wordFrequency.viz.wordCloudConfig.title')}
            style={{
              maxWidth: '100%',
              maxHeight: '100%',
              objectFit: 'contain',
              cursor: onWordClick ? 'pointer' : 'default'
            }}
            onClick={handleImageClick}
          />
        </Box>
      )}

      {/* Fallback for unexpected state */}
      {!loading && !error && !imageData && data.length > 0 && (
        <Box 
          sx={{ 
            flex: 1, 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center',
            color: 'text.secondary',
            flexDirection: 'column',
            gap: 2
          }}
        >
          <CircularProgress />
          <Typography variant="body2" color="text.secondary">
            {t('wordFrequency.viz.wordCloudConfig.generating')}
          </Typography>
        </Box>
      )}
    </Box>
  )
}
